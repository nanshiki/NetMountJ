// SPDX-License-Identifier: GPL-2.0-only
// Copyright 2025 Jaroslav Rohel, jaroslav.rohel@gmail.com

#include <process.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define PROGRAM_VERSION "1.0"

#define IP_ARG      "/IP:"
#define MASK_ARG    "/MASK:"
#define GW_ARG      "/GW:"
#define PKT_INT_ARG "/PKT_INT:"
#define MTU_ARG     "/MTU:"

#define MAX_EXTRA_ARGS 10
#define MAX_KEY_LEN    9
#define MAX_VALUE_LEN  15

enum State { KEY, VALUE, IGNORE };

int main(int argc, char * argv[]) {
    if ((argc < 2) || (argc > 2 + MAX_EXTRA_ARGS)) {
        printf(
            "NInstall " PROGRAM_VERSION
            ", Copyright 2025 Jaroslav Rohel <jaroslav.rohel@gmail.com>\n"
            "NInstall comes with ABSOLUTELY NO WARRANTY. This is free software,\n"
            "and you are welcome to redistribute it under the terms of the GNU GPL v2.\n"
            "\n"
            "The \"ninstall\" utility installs the DOS TSR NetMount driver using\n"
            "parameters specified in a configuration file. Specifically, it launches\n"
            "\"NETMOUNT INSTALL\" in the current working directory and passes\n"
            "the supported parameters from the file as command-line arguments.\n"
            "The user may also provide additional arguments.\n"
            "\n"
            "The configuration file must contains lines in the format <key> <value>.\n"
            "Supported keys are: IPADDR, NETMASK, GATEWAY, PACKETINT, and MTU.\n"
            "The file must include the IPADDR key; all other keys are optional.\n"
            "All other lines are ignored.\n"
            "\n"
            "This format was chosen to be compatible with the configuration file used\n"
            "by the mTCP project. For example, a file generated by the mTCP DHCP\n"
            "client can be used directly.\n"
            "\n"
            "Executes:\n"
            "NETMOUNT INSTALL /IP:<local_ipv4_addr> [/MASK:<net_mask>]\n"
            "                 [/GW:<gateway_addr>] [/PKT_INT:<pkt_int>] [/MTU:<size>]\n"
            "                 [<additional_arg1> ... <additional_argN>]\n"
            "\n"
            "Usage:\n"
            "NINSTALL <config_file> [<extra_arg1> [<extra_arg2>] ... [<extra_argN>]]\n"
            "  (up to %d additional arguments)\n"
            "\n"
            "Arguments:\n"
            "<config_file>      Path to a configuration file in mTCP format\n"
            "<local_ipv4_addr>  IPADDR value from the <config_file>\n"
            "<net_mask>         NETMASK value from the <config_file>\n"
            "<gateway_addr>     GATEWAY value from the <config_file>\n"
            "<pkt_int>          PACKETINT value from the <config_file>\n"
            "<size>             MTU value from the <config_file>\n"
            "<extra_argX>       Additional argument passed to the NETMOUNT INSTALL command\n",
            MAX_EXTRA_ARGS);
        return 1;
    }

    FILE * const f = fopen(argv[1], "r");
    if (!f) {
        printf("Error opening file: %s\n", argv[1]);
        return 1;
    }

    char key[MAX_KEY_LEN + 1];
    char ip[sizeof(IP_ARG) + MAX_VALUE_LEN] = IP_ARG;
    char mask[sizeof(MASK_ARG) + MAX_VALUE_LEN] = MASK_ARG;
    char gw[sizeof(GW_ARG) + MAX_VALUE_LEN] = GW_ARG;
    char pkt_int[sizeof(PKT_INT_ARG) + MAX_VALUE_LEN] = PKT_INT_ARG;
    char mtu[sizeof(MTU_ARG) + MAX_VALUE_LEN] = MTU_ARG;
    bool is_ip_set = false;
    bool is_mask_set = false;
    bool is_gw_set = false;
    bool is_pkt_int_set = false;
    bool is_mtu_set = false;

    enum State state = KEY;
    char * value;
    bool * is_value_set;
    int idx = 0;
    for (int ch; (ch = fgetc(f)) != EOF;) {
        switch (state) {
            case KEY:
                if (idx == 0) {
                    if (ch == '#') {
                        // skip comment lines
                        state = IGNORE;
                        continue;
                    }
                    if (ch == '\r' || ch == '\n') {
                        // skip empty lines
                        continue;
                    }
                }
                if (ch == ' ') {
                    key[idx] = '\0';
                    strupr(key);
                    if (strcmp(key, "IPADDR") == 0) {
                        value = ip + sizeof(IP_ARG) - 1;
                        is_value_set = &is_ip_set;
                    } else if (strcmp(key, "NETMASK") == 0) {
                        value = mask + sizeof(MASK_ARG) - 1;
                        is_value_set = &is_mask_set;
                    } else if (strcmp(key, "GATEWAY") == 0) {
                        value = gw + sizeof(GW_ARG) - 1;
                        is_value_set = &is_gw_set;
                    } else if (strcmp(key, "PACKETINT") == 0) {
                        value = pkt_int + sizeof(PKT_INT_ARG) - 1;
                        is_value_set = &is_pkt_int_set;
                    } else if (strcmp(key, "MTU") == 0) {
                        value = mtu + sizeof(MTU_ARG) - 1;
                        is_value_set = &is_mtu_set;
                    } else {
                        state = IGNORE;
                        continue;
                    }
                    idx = 0;
                    state = VALUE;
                    continue;
                }
                if (idx < MAX_KEY_LEN) {
                    key[idx++] = ch;
                } else {
                    state = IGNORE;
                }
                break;
            case VALUE:
                if (ch == '\r' || ch == '\n') {
                    value[idx] = '\0';
                    if (strcmp(key, "PACKETINT") == 0) {
                        // convert to decimal
                        int pkt_interrupt = strtol(value, NULL, 0);
                        if (pkt_interrupt < 0x10 || pkt_interrupt > 0xFF) {
                            printf("Unsupported packet driver interrupt: %x\n", pkt_interrupt);
                            fclose(f);
                            return 1;
                        }
                        itoa(pkt_interrupt, value, 10);
                    }
                    *is_value_set = true;
                    idx = 0;
                    state = KEY;
                    continue;
                }
                if (idx < MAX_VALUE_LEN) {
                    value[idx++] = ch;
                } else {
                    state = IGNORE;
                }
                break;
            case IGNORE:
                if (ch == '\r' || ch == '\n') {
                    idx = 0;
                    state = KEY;
                }
        }
    }

    fclose(f);

    if (ip[sizeof(IP_ARG) - 1] == '\0') {
        printf("Missing required configuration value IPADDR in config file.\n");
        return 1;
    }

    // Prepare args
    char const * args[MAX_EXTRA_ARGS + 7 + 1];
    int args_idx = 0;
    args[args_idx++] = "NETMOUNT";
    args[args_idx++] = "INSTALL";
    args[args_idx++] = ip;
    if (is_mask_set) {
        args[args_idx++] = mask;
    }
    if (is_gw_set) {
        args[args_idx++] = gw;
    }
    if (is_pkt_int_set) {
        args[args_idx++] = pkt_int;
    }
    if (is_mtu_set) {
        args[args_idx++] = mtu;
    }
    for (int i = 2; i < argc; ++i) {
        args[args_idx++] = argv[i];
    }
    args[args_idx] = NULL;

    // Show what we're about to run
    printf("Exec:");
    for (int idx = 0; args[idx] != NULL; ++idx) {
        printf(" %s", args[idx]);
    }
    printf("\n");

    // Execute netmount
    int result = execvp("NETMOUNT", args);

    printf("Failed to run netmount (error %d)\n", result);
    return 1;
}
